/* automatically generated by rust-bindgen 0.56.0 */
use std::os::raw::*;
pub const OPJ_TRUE: u32 = 1;
pub const OPJ_FALSE: u32 = 0;
pub const OPJ_VERSION_MAJOR: u32 = 2;
pub const OPJ_VERSION_MINOR: u32 = 3;
pub const OPJ_VERSION_BUILD: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &'static [u8; 1usize] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const OPJ_PATH_LEN: u32 = 4096;
pub const OPJ_J2K_MAXRLVLS: u32 = 33;
pub const OPJ_J2K_MAXBANDS: u32 = 97;
pub const OPJ_J2K_DEFAULT_NB_SEGS: u32 = 10;
pub const OPJ_J2K_STREAM_CHUNK_SIZE: u32 = 1048576;
pub const OPJ_J2K_DEFAULT_HEADER_SIZE: u32 = 1000;
pub const OPJ_J2K_MCC_DEFAULT_NB_RECORDS: u32 = 10;
pub const OPJ_J2K_MCT_DEFAULT_NB_RECORDS: u32 = 10;
pub const JPWL_MAX_NO_TILESPECS: u32 = 16;
pub const JPWL_MAX_NO_PACKSPECS: u32 = 16;
pub const JPWL_MAX_NO_MARKERS: u32 = 512;
pub const JPWL_PRIVATEINDEX_NAME: &'static [u8; 27usize] = b"jpwl_index_privatefilename\0";
pub const JPWL_EXPECTED_COMPONENTS: u32 = 3;
pub const JPWL_MAXIMUM_TILES: u32 = 8192;
pub const JPWL_MAXIMUM_HAMMING: u32 = 2;
pub const JPWL_MAXIMUM_EPB_ROOM: u32 = 65450;
pub const OPJ_IMG_INFO: u32 = 1;
pub const OPJ_J2K_MH_INFO: u32 = 2;
pub const OPJ_J2K_TH_INFO: u32 = 4;
pub const OPJ_J2K_TCH_INFO: u32 = 8;
pub const OPJ_J2K_MH_IND: u32 = 16;
pub const OPJ_J2K_TH_IND: u32 = 32;
pub const OPJ_JP2_INFO: u32 = 128;
pub const OPJ_JP2_IND: u32 = 256;
pub const OPJ_PROFILE_NONE: u32 = 0;
pub const OPJ_PROFILE_0: u32 = 1;
pub const OPJ_PROFILE_1: u32 = 2;
pub const OPJ_PROFILE_PART2: u32 = 32768;
pub const OPJ_PROFILE_CINEMA_2K: u32 = 3;
pub const OPJ_PROFILE_CINEMA_4K: u32 = 4;
pub const OPJ_PROFILE_CINEMA_S2K: u32 = 5;
pub const OPJ_PROFILE_CINEMA_S4K: u32 = 6;
pub const OPJ_PROFILE_CINEMA_LTS: u32 = 7;
pub const OPJ_PROFILE_BC_SINGLE: u32 = 256;
pub const OPJ_PROFILE_BC_MULTI: u32 = 512;
pub const OPJ_PROFILE_BC_MULTI_R: u32 = 768;
pub const OPJ_PROFILE_IMF_2K: u32 = 1024;
pub const OPJ_PROFILE_IMF_4K: u32 = 1025;
pub const OPJ_PROFILE_IMF_8K: u32 = 1026;
pub const OPJ_PROFILE_IMF_2K_R: u32 = 1027;
pub const OPJ_PROFILE_IMF_4K_R: u32 = 2048;
pub const OPJ_PROFILE_IMF_8K_R: u32 = 2049;
pub const OPJ_EXTENSION_NONE: u32 = 0;
pub const OPJ_EXTENSION_MCT: u32 = 256;
pub const OPJ_CINEMA_24_CS: u32 = 1302083;
pub const OPJ_CINEMA_48_CS: u32 = 651041;
pub const OPJ_CINEMA_24_COMP: u32 = 1041666;
pub const OPJ_CINEMA_48_COMP: u32 = 520833;
pub const OPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG: u32 = 1;
pub const OPJ_DPARAMETERS_DUMP_FLAG: u32 = 2;
pub const OPJ_STREAM_READ: u32 = 1;
pub const OPJ_STREAM_WRITE: u32 = 0;
pub type OPJ_BOOL = c_int;
pub type OPJ_CHAR = c_char;
pub type OPJ_FLOAT32 = f32;
pub type OPJ_FLOAT64 = f64;
pub type OPJ_BYTE = u8;
pub type OPJ_INT8 = i8;
pub type OPJ_UINT8 = u8;
pub type OPJ_INT16 = i16;
pub type OPJ_UINT16 = u16;
pub type OPJ_INT32 = i32;
pub type OPJ_UINT32 = u32;
pub type OPJ_INT64 = i64;
pub type OPJ_UINT64 = u64;
pub type OPJ_OFF_T = i64;
pub type va_list = *mut c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut c_char, ...);
}
pub type size_t = c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = c_int;
pub type wint_t = c_ushort;
pub type wctype_t = c_ushort;
pub type __time32_t = c_long;
pub type __time64_t = c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const c_ushort,
    pub _locale_mb_cur_max: c_int,
    pub _locale_lc_codepage: c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: c_ulong,
    pub _Byte: c_ushort,
    pub _State: c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut c_void,
}
use libc::FILE;
extern "C" {
    pub fn __acrt_iob_func(_Ix: c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(_Buffer: *mut wchar_t, _BufferCount: c_int, _Stream: *mut FILE) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(_FileName: *const wchar_t, _Mode: *const wchar_t, _ShFlag: c_int) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: size_t) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _MaxCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
pub type fpos_t = c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut c_char,
        _Pointer: *mut *mut *mut c_char,
        _Count: *mut *mut c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const c_char,
        _Mode: *const c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut c_void,
        _BufferSize: size_t,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const c_char,
        _Mode: *const c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(_Buffer: *mut c_char, _Size: rsize_t) -> *mut c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _fcloseall() -> c_int;
}
extern "C" {
    pub fn _fdopen(_FileHandle: c_int, _Mode: *const c_char) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _fgetchar() -> c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> c_int;
}
extern "C" {
    pub fn fgets(_Buffer: *mut c_char, _MaxCount: c_int, _Stream: *mut FILE) -> *mut c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _flushall() -> c_int;
}
extern "C" {
    pub fn fopen(_FileName: *const c_char, _Mode: *const c_char) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _fputchar(_Character: c_int) -> c_int;
}
extern "C" {
    pub fn fputs(_Buffer: *const c_char, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut c_void,
        _ElementSize: c_ulonglong,
        _ElementCount: c_ulonglong,
        _Stream: *mut FILE,
    ) -> c_ulonglong;
}
extern "C" {
    pub fn freopen(_FileName: *const c_char, _Mode: *const c_char, _Stream: *mut FILE)
        -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(_FileName: *const c_char, _Mode: *const c_char, _ShFlag: c_int) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> c_int;
}
extern "C" {
    pub fn fseek(_Stream: *mut FILE, _Offset: c_long, _Origin: c_int) -> c_int;
}
extern "C" {
    pub fn _fseeki64(_Stream: *mut FILE, _Offset: c_longlong, _Origin: c_int) -> c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const c_void,
        _ElementSize: c_ulonglong,
        _ElementCount: c_ulonglong,
        _Stream: *mut FILE,
    ) -> c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn getchar() -> c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _popen(_Command: *const c_char, _Mode: *const c_char) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn putchar(_Character: c_int) -> c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const c_char) -> c_int;
}
extern "C" {
    pub fn _putw(_Word: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn remove(_FileName: *const c_char) -> c_int;
}
extern "C" {
    pub fn rename(_OldFileName: *const c_char, _NewFileName: *const c_char) -> c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const c_char) -> c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const c_char) -> c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: c_int) -> c_int;
}
extern "C" {
    pub fn setvbuf(_Stream: *mut FILE, _Buffer: *mut c_char, _Mode: c_int, _Size: size_t) -> c_int;
}
extern "C" {
    pub fn _tempnam(_DirectoryName: *const c_char, _FilePrefix: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut c_char) -> *mut c_char;
}
extern "C" {
    pub fn ungetc(_Character: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _fputc_nolock(_Character: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut c_void,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut c_void,
        _BufferSize: size_t,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fseek_nolock(_Stream: *mut FILE, _Offset: c_long, _Origin: c_int) -> c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(_Stream: *mut FILE, _Offset: c_longlong, _Origin: c_int) -> c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const c_void,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _putc_nolock(_Character: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn _ungetc_nolock(_Character: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: c_int) -> c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: c_ulonglong,
        _Buffer: *mut c_char,
        _BufferCount: size_t,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: c_ulonglong,
        _Buffer: *mut c_char,
        _BufferCount: size_t,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: c_ulonglong,
        _Buffer: *mut c_char,
        _BufferCount: size_t,
        _MaxCount: size_t,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: c_ulonglong,
        _Buffer: *mut c_char,
        _BufferCount: size_t,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: c_ulonglong,
        _Buffer: *const c_char,
        _BufferCount: size_t,
        _Format: *const c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> c_int;
}
extern "C" {
    pub fn tempnam(_Directory: *const c_char, _FilePrefix: *const c_char) -> *mut c_char;
}
extern "C" {
    pub fn fcloseall() -> c_int;
}
extern "C" {
    pub fn fdopen(_FileHandle: c_int, _Format: *const c_char) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn flushall() -> c_int;
}
extern "C" {
    pub fn fputchar(_Ch: c_int) -> c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn putw(_Ch: c_int, _Stream: *mut FILE) -> c_int;
}
extern "C" {
    pub fn rmtmp() -> c_int;
}
pub type OPJ_SIZE_T = size_t;
#[repr(i32)]
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Rsiz Capabilities"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    #[doc = " Standard JPEG2000 profile"]
    OPJ_CINEMA2K = 3,
    #[doc = " Profile name for a 2K image"]
    OPJ_CINEMA4K = 4,
    #[doc = " Profile name for a 4K image"]
    OPJ_MCT = 33024,
}
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Rsiz Capabilities"]
pub use self::RSIZ_CAPABILITIES as OPJ_RSIZ_CAPABILITIES;
#[repr(i32)]
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Digital cinema operation mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CINEMA_MODE {
    OPJ_OFF = 0,
    #[doc = " Not Digital Cinema"]
    OPJ_CINEMA2K_24 = 1,
    #[doc = " 2K Digital Cinema at 24 fps"]
    OPJ_CINEMA2K_48 = 2,
    #[doc = " 2K Digital Cinema at 48 fps"]
    OPJ_CINEMA4K_24 = 3,
}
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Digital cinema operation mode"]
pub use self::CINEMA_MODE as OPJ_CINEMA_MODE;
#[repr(i32)]
#[doc = " Progression order"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PROG_ORDER {
    #[doc = "< place-holder"]
    OPJ_PROG_UNKNOWN = -1,
    #[doc = "< layer-resolution-component-precinct order"]
    OPJ_LRCP = 0,
    #[doc = "< resolution-layer-component-precinct order"]
    OPJ_RLCP = 1,
    #[doc = "< resolution-precinct-component-layer order"]
    OPJ_RPCL = 2,
    #[doc = "< precinct-component-resolution-layer order"]
    OPJ_PCRL = 3,
    #[doc = "< component-precinct-resolution-layer order"]
    OPJ_CPRL = 4,
}
#[doc = " Progression order"]
pub use self::PROG_ORDER as OPJ_PROG_ORDER;
#[repr(i32)]
#[doc = " Supported image color spaces"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum COLOR_SPACE {
    #[doc = "< not supported by the library"]
    OPJ_CLRSPC_UNKNOWN = -1,
    #[doc = "< not specified in the codestream"]
    OPJ_CLRSPC_UNSPECIFIED = 0,
    #[doc = "< sRGB"]
    OPJ_CLRSPC_SRGB = 1,
    #[doc = "< grayscale"]
    OPJ_CLRSPC_GRAY = 2,
    #[doc = "< YUV"]
    OPJ_CLRSPC_SYCC = 3,
    #[doc = "< e-YCC"]
    OPJ_CLRSPC_EYCC = 4,
    #[doc = "< CMYK"]
    OPJ_CLRSPC_CMYK = 5,
}
#[doc = " Supported image color spaces"]
pub use self::COLOR_SPACE as OPJ_COLOR_SPACE;
#[repr(i32)]
#[doc = " Supported codec"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CODEC_FORMAT {
    #[doc = "< place-holder"]
    OPJ_CODEC_UNKNOWN = -1,
    #[doc = "< JPEG-2000 codestream : read/write"]
    OPJ_CODEC_J2K = 0,
    #[doc = "< JPT-stream (JPEG 2000, JPIP) : read only"]
    OPJ_CODEC_JPT = 1,
    #[doc = "< JP2 file format : read/write"]
    OPJ_CODEC_JP2 = 2,
    #[doc = "< JPP-stream (JPEG 2000, JPIP) : to be coded"]
    OPJ_CODEC_JPP = 3,
    #[doc = "< JPX file format (JPEG 2000 Part-2) : to be coded"]
    OPJ_CODEC_JPX = 4,
}
#[doc = " Supported codec"]
pub use self::CODEC_FORMAT as OPJ_CODEC_FORMAT;
#[doc = " Callback function prototype for events"]
#[doc = "* `msg` —                Event message"]
#[doc = "* `client_data` —        Client object where will be return the event message"]
pub type opj_msg_callback =
    ::std::option::Option<unsafe extern "C" fn(msg: *const c_char, client_data: *mut c_void)>;
#[doc = " Progression order changes"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_poc {
    #[doc = " Resolution num start, Component num start, given by POC"]
    pub resno0: OPJ_UINT32,
    #[doc = " Resolution num start, Component num start, given by POC"]
    pub compno0: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub layno1: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub resno1: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub compno1: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub layno0: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub precno0: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub precno1: OPJ_UINT32,
    #[doc = " Progression order enum"]
    pub prg1: OPJ_PROG_ORDER,
    #[doc = " Progression order enum"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = " Progression order string"]
    pub progorder: [OPJ_CHAR; 5usize],
    #[doc = " Tile number (starting at 1)"]
    pub tile: OPJ_UINT32,
    #[doc = " Start and end values for Tile width and height"]
    pub tx0: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub tx1: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub ty0: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub ty1: OPJ_INT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub layS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub resS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub compS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub prcS: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub layE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub resE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub compE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub prcE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txS: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyS: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dx: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dy: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub lay_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub res_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub comp_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub prc_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub tx0_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub ty0_t: OPJ_UINT32,
}
#[doc = " Progression order changes"]
#[doc = ""]
pub type opj_poc_t = opj_poc;
#[doc = " Compression parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_cparameters {
    #[doc = " size of tile: tile_size_on = false (not in argument) or = true (in argument)"]
    pub tile_size_on: OPJ_BOOL,
    #[doc = " XTOsiz"]
    pub cp_tx0: c_int,
    #[doc = " YTOsiz"]
    pub cp_ty0: c_int,
    #[doc = " XTsiz"]
    pub cp_tdx: c_int,
    #[doc = " YTsiz"]
    pub cp_tdy: c_int,
    #[doc = " allocation by rate/distortion"]
    pub cp_disto_alloc: c_int,
    #[doc = " allocation by fixed layer"]
    pub cp_fixed_alloc: c_int,
    #[doc = " add fixed_quality"]
    pub cp_fixed_quality: c_int,
    #[doc = " fixed layer"]
    pub cp_matrice: *mut c_int,
    #[doc = " comment for coding"]
    pub cp_comment: *mut c_char,
    #[doc = " csty : coding style"]
    pub csty: c_int,
    #[doc = " progression order (default OPJ_LRCP)"]
    pub prog_order: OPJ_PROG_ORDER,
    #[doc = " progression order changes"]
    pub POC: [opj_poc_t; 32usize],
    #[doc = " number of progression order changes (POC), default to 0"]
    pub numpocs: OPJ_UINT32,
    #[doc = " number of layers"]
    pub tcp_numlayers: c_int,
    #[doc = " rates of layers - might be subsequently limited by the max_cs_size field."]
    #[doc = " Should be decreasing. 1 can be"]
    #[doc = " used as last value to indicate the last layer is lossless."]
    pub tcp_rates: [f32; 100usize],
    #[doc = " different psnr for successive layers. Should be increasing. 0 can be"]
    #[doc = " used as last value to indicate the last layer is lossless."]
    pub tcp_distoratio: [f32; 100usize],
    #[doc = " number of resolutions"]
    pub numresolution: c_int,
    #[doc = " initial code block width, default to 64"]
    pub cblockw_init: c_int,
    #[doc = " initial code block height, default to 64"]
    pub cblockh_init: c_int,
    #[doc = " mode switch (cblk_style)"]
    pub mode: c_int,
    #[doc = " 1 : use the irreversible DWT 9-7, 0 : use lossless compression (default)"]
    pub irreversible: c_int,
    #[doc = " region of interest: affected component in [0..3], -1 means no ROI"]
    pub roi_compno: c_int,
    #[doc = " region of interest: upshift value"]
    pub roi_shift: c_int,
    pub res_spec: c_int,
    #[doc = " initial precinct width"]
    pub prcw_init: [c_int; 33usize],
    #[doc = " initial precinct height"]
    pub prch_init: [c_int; 33usize],
    #[doc = " input file name"]
    pub infile: [c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [c_char; 4096usize],
    #[doc = " DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL"]
    pub index_on: c_int,
    #[doc = " DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL"]
    pub index: [c_char; 4096usize],
    #[doc = " subimage encoding: origin image offset in x direction"]
    pub image_offset_x0: c_int,
    #[doc = " subimage encoding: origin image offset in y direction"]
    pub image_offset_y0: c_int,
    #[doc = " subsampling value for dx"]
    pub subsampling_dx: c_int,
    #[doc = " subsampling value for dy"]
    pub subsampling_dy: c_int,
    #[doc = " input file format 0: PGX, 1: PxM, 2: BMP 3:TIF"]
    pub decod_format: c_int,
    #[doc = " output file format 0: J2K, 1: JP2, 2: JPT"]
    pub cod_format: c_int,
    #[doc = " enables writing of EPC in MH, thus activating JPWL"]
    pub jpwl_epc_on: OPJ_BOOL,
    #[doc = " error protection method for MH (0,1,16,32,37-128)"]
    pub jpwl_hprot_MH: c_int,
    #[doc = " tile number of header protection specification (>=0)"]
    pub jpwl_hprot_TPH_tileno: [c_int; 16usize],
    #[doc = " error protection methods for TPHs (0,1,16,32,37-128)"]
    pub jpwl_hprot_TPH: [c_int; 16usize],
    #[doc = " tile number of packet protection specification (>=0)"]
    pub jpwl_pprot_tileno: [c_int; 16usize],
    #[doc = " packet number of packet protection specification (>=0)"]
    pub jpwl_pprot_packno: [c_int; 16usize],
    #[doc = " error protection methods for packets (0,1,16,32,37-128)"]
    pub jpwl_pprot: [c_int; 16usize],
    #[doc = " enables writing of ESD, (0=no/1/2 bytes)"]
    pub jpwl_sens_size: c_int,
    #[doc = " sensitivity addressing size (0=auto/2/4 bytes)"]
    pub jpwl_sens_addr: c_int,
    #[doc = " sensitivity range (0-3)"]
    pub jpwl_sens_range: c_int,
    #[doc = " sensitivity method for MH (-1=no,0-7)"]
    pub jpwl_sens_MH: c_int,
    #[doc = " tile number of sensitivity specification (>=0)"]
    pub jpwl_sens_TPH_tileno: [c_int; 16usize],
    #[doc = " sensitivity methods for TPHs (-1=no,0-7)"]
    pub jpwl_sens_TPH: [c_int; 16usize],
    #[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and MAX_COMP_SIZE instead"]
    #[doc = " Digital Cinema compliance 0-not compliant, 1-compliant"]
    pub cp_cinema: OPJ_CINEMA_MODE,
    #[doc = " Maximum size (in bytes) for each component."]
    #[doc = " If == 0, component size limitation is not considered"]
    pub max_comp_size: c_int,
    #[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
    #[doc = " Profile name"]
    pub cp_rsiz: OPJ_RSIZ_CAPABILITIES,
    #[doc = " Tile part generation"]
    pub tp_on: c_char,
    #[doc = " Flag for Tile part generation"]
    pub tp_flag: c_char,
    #[doc = " MCT (multiple component transform)"]
    pub tcp_mct: c_char,
    #[doc = " Enable JPIP indexing"]
    pub jpip_on: OPJ_BOOL,
    #[doc = " Naive implementation of MCT restricted to a single reversible array based"]
    #[doc = "encoding without offset concerning all the components."]
    pub mct_data: *mut c_void,
    #[doc = " Maximum size (in bytes) for the whole codestream."]
    #[doc = " If == 0, codestream size limitation is not considered"]
    #[doc = " If it does not comply with tcp_rates, max_cs_size prevails"]
    #[doc = " and a warning is issued."]
    pub max_cs_size: c_int,
    #[doc = " RSIZ value"]
    #[doc = "To be used to combine OPJ_PROFILE_*, OPJ_EXTENSION_* and (sub)levels values."]
    pub rsiz: OPJ_UINT16,
}
#[doc = " Compression parameters"]
pub type opj_cparameters_t = opj_cparameters;
#[doc = " Decompression parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_dparameters {
    #[doc = "Set the number of highest resolution levels to be discarded."]
    #[doc = "The image resolution is effectively divided by 2 to the power of the number of discarded levels."]
    #[doc = "The reduce factor is limited by the smallest total number of decomposition levels among tiles."]
    #[doc = "if != 0, then original dimension divided by 2^(reduce);"]
    #[doc = "if == 0 or not used, image is decoded to the full resolution"]
    pub cp_reduce: OPJ_UINT32,
    #[doc = "Set the maximum number of quality layers to decode."]
    #[doc = "If there are less quality layers than the specified number, all the quality layers are decoded."]
    #[doc = "if != 0, then only the first \"layer\" layers are decoded;"]
    #[doc = "if == 0 or not used, all the quality layers are decoded"]
    pub cp_layer: OPJ_UINT32,
    #[doc = " input file name"]
    pub infile: [c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [c_char; 4096usize],
    #[doc = " input file format 0: J2K, 1: JP2, 2: JPT"]
    pub decod_format: c_int,
    #[doc = " output file format 0: PGX, 1: PxM, 2: BMP"]
    pub cod_format: c_int,
    #[doc = " Decoding area left boundary"]
    pub DA_x0: OPJ_UINT32,
    #[doc = " Decoding area right boundary"]
    pub DA_x1: OPJ_UINT32,
    #[doc = " Decoding area up boundary"]
    pub DA_y0: OPJ_UINT32,
    #[doc = " Decoding area bottom boundary"]
    pub DA_y1: OPJ_UINT32,
    #[doc = " Verbose mode"]
    pub m_verbose: OPJ_BOOL,
    #[doc = " tile number of the decoded tile"]
    pub tile_index: OPJ_UINT32,
    #[doc = " Nb of tile to decode"]
    pub nb_tile_to_decode: OPJ_UINT32,
    #[doc = " activates the JPWL correction capabilities"]
    pub jpwl_correct: OPJ_BOOL,
    #[doc = " expected number of components"]
    pub jpwl_exp_comps: c_int,
    #[doc = " maximum number of tiles"]
    pub jpwl_max_tiles: c_int,
    pub flags: c_uint,
}
#[doc = " Decompression parameters"]
pub type opj_dparameters_t = opj_dparameters;
#[doc = " JPEG2000 codec V2."]
pub type opj_codec_t = *mut c_void;
pub type opj_stream_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_skip_fn = ::std::option::Option<
    unsafe extern "C" fn(p_nb_bytes: OPJ_OFF_T, p_user_data: *mut c_void) -> OPJ_OFF_T,
>;
pub type opj_stream_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(p_nb_bytes: OPJ_OFF_T, p_user_data: *mut c_void) -> OPJ_BOOL,
>;
pub type opj_stream_free_user_data_fn =
    ::std::option::Option<unsafe extern "C" fn(p_user_data: *mut c_void)>;
pub type opj_stream_t = *mut c_void;
#[doc = " Defines a single image component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comp {
    #[doc = " XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = " YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = " data width"]
    pub w: OPJ_UINT32,
    #[doc = " data height"]
    pub h: OPJ_UINT32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = " precision"]
    pub prec: OPJ_UINT32,
    #[doc = " image depth in bits"]
    pub bpp: OPJ_UINT32,
    #[doc = " signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
    #[doc = " number of decoded resolution"]
    pub resno_decoded: OPJ_UINT32,
    #[doc = " number of division by 2 of the out image compared to the original size of image"]
    pub factor: OPJ_UINT32,
    #[doc = " image component data"]
    pub data: *mut OPJ_INT32,
    #[doc = " alpha channel"]
    pub alpha: OPJ_UINT16,
}
#[doc = " Defines a single image component"]
pub type opj_image_comp_t = opj_image_comp;
#[doc = " Defines image data and characteristics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image {
    #[doc = " XOsiz: horizontal offset from the origin of the reference grid to the left side of the image area"]
    pub x0: OPJ_UINT32,
    #[doc = " YOsiz: vertical offset from the origin of the reference grid to the top side of the image area"]
    pub y0: OPJ_UINT32,
    #[doc = " Xsiz: width of the reference grid"]
    pub x1: OPJ_UINT32,
    #[doc = " Ysiz: height of the reference grid"]
    pub y1: OPJ_UINT32,
    #[doc = " number of components in the image"]
    pub numcomps: OPJ_UINT32,
    #[doc = " color space: sRGB, Greyscale or YUV"]
    pub color_space: OPJ_COLOR_SPACE,
    #[doc = " image components"]
    pub comps: *mut opj_image_comp_t,
    #[doc = " 'restricted' ICC profile"]
    pub icc_profile_buf: *mut OPJ_BYTE,
    #[doc = " size of ICC profile"]
    pub icc_profile_len: OPJ_UINT32,
}
#[doc = " Defines image data and characteristics"]
pub type opj_image_t = opj_image;
#[doc = " Component parameters structure used by the opj_image_create function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comptparm {
    #[doc = " XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = " YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = " data width"]
    pub w: OPJ_UINT32,
    #[doc = " data height"]
    pub h: OPJ_UINT32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = " precision"]
    pub prec: OPJ_UINT32,
    #[doc = " image depth in bits"]
    pub bpp: OPJ_UINT32,
    #[doc = " signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
}
#[doc = " Component parameters structure used by the opj_image_create function"]
pub type opj_image_cmptparm_t = opj_image_comptparm;
#[doc = " Index structure : Information concerning a packet inside tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_packet_info {
    #[doc = " packet start position (including SOP marker if it exists)"]
    pub start_pos: OPJ_OFF_T,
    #[doc = " end of packet header position (including EPH marker if it exists)"]
    pub end_ph_pos: OPJ_OFF_T,
    #[doc = " packet end position"]
    pub end_pos: OPJ_OFF_T,
    #[doc = " packet distorsion"]
    pub disto: f64,
}
#[doc = " Index structure : Information concerning a packet inside tile"]
pub type opj_packet_info_t = opj_packet_info;
#[doc = " Marker structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_marker_info {
    #[doc = " marker type"]
    pub type_: c_ushort,
    #[doc = " position in codestream"]
    pub pos: OPJ_OFF_T,
    #[doc = " length, marker val included"]
    pub len: c_int,
}
#[doc = " Marker structure"]
pub type opj_marker_info_t = opj_marker_info;
#[doc = " Index structure : Information concerning tile-parts"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_info {
    #[doc = " start position of tile part"]
    pub tp_start_pos: c_int,
    #[doc = " end position of tile part header"]
    pub tp_end_header: c_int,
    #[doc = " end position of tile part"]
    pub tp_end_pos: c_int,
    #[doc = " start packet of tile part"]
    pub tp_start_pack: c_int,
    #[doc = " number of packets of tile part"]
    pub tp_numpacks: c_int,
}
#[doc = " Index structure : Information concerning tile-parts"]
pub type opj_tp_info_t = opj_tp_info;
#[doc = " Index structure : information regarding tiles"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_tile_info {
    #[doc = " value of thresh for each layer by tile cfr. Marcela"]
    pub thresh: *mut f64,
    #[doc = " number of tile"]
    pub tileno: c_int,
    #[doc = " start position"]
    pub start_pos: c_int,
    #[doc = " end position of the header"]
    pub end_header: c_int,
    #[doc = " end position"]
    pub end_pos: c_int,
    #[doc = " precinct number for each resolution level (width)"]
    pub pw: [c_int; 33usize],
    #[doc = " precinct number for each resolution level (height)"]
    pub ph: [c_int; 33usize],
    #[doc = " precinct size (in power of 2), in X for each resolution level"]
    pub pdx: [c_int; 33usize],
    #[doc = " precinct size (in power of 2), in Y for each resolution level"]
    pub pdy: [c_int; 33usize],
    #[doc = " information concerning packets inside tile"]
    pub packet: *mut opj_packet_info_t,
    #[doc = " add fixed_quality"]
    pub numpix: c_int,
    #[doc = " add fixed_quality"]
    pub distotile: f64,
    #[doc = " number of markers"]
    pub marknum: c_int,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: c_int,
    #[doc = " number of tile parts"]
    pub num_tps: c_int,
    #[doc = " information concerning tile parts"]
    pub tp: *mut opj_tp_info_t,
}
#[doc = " Index structure : information regarding tiles"]
pub type opj_tile_info_t = opj_tile_info;
#[doc = " Index structure of the codestream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info {
    #[doc = " maximum distortion reduction on the whole image (add for Marcela)"]
    pub D_max: f64,
    #[doc = " packet number"]
    pub packno: c_int,
    #[doc = " writing the packet in the index with t2_encode_packets"]
    pub index_write: c_int,
    #[doc = " image width"]
    pub image_w: c_int,
    #[doc = " image height"]
    pub image_h: c_int,
    #[doc = " progression order"]
    pub prog: OPJ_PROG_ORDER,
    #[doc = " tile size in x"]
    pub tile_x: c_int,
    #[doc = " tile size in y"]
    pub tile_y: c_int,
    pub tile_Ox: c_int,
    pub tile_Oy: c_int,
    #[doc = " number of tiles in X"]
    pub tw: c_int,
    #[doc = " number of tiles in Y"]
    pub th: c_int,
    #[doc = " component numbers"]
    pub numcomps: c_int,
    #[doc = " number of layer"]
    pub numlayers: c_int,
    #[doc = " number of decomposition for each component"]
    pub numdecompos: *mut c_int,
    #[doc = " number of markers"]
    pub marknum: c_int,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: c_int,
    #[doc = " main header position"]
    pub main_head_start: c_int,
    #[doc = " main header position"]
    pub main_head_end: c_int,
    #[doc = " codestream's size"]
    pub codestream_size: c_int,
    #[doc = " information regarding tiles inside image"]
    pub tile: *mut opj_tile_info_t,
}
#[doc = " Index structure of the codestream"]
pub type opj_codestream_info_t = opj_codestream_info;
#[doc = " Tile-component coding parameters information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_tccp_info {
    #[doc = " component index"]
    pub compno: OPJ_UINT32,
    #[doc = " coding style"]
    pub csty: OPJ_UINT32,
    #[doc = " number of resolutions"]
    pub numresolutions: OPJ_UINT32,
    #[doc = " log2 of code-blocks width"]
    pub cblkw: OPJ_UINT32,
    #[doc = " log2 of code-blocks height"]
    pub cblkh: OPJ_UINT32,
    #[doc = " code-block coding style"]
    pub cblksty: OPJ_UINT32,
    #[doc = " discrete wavelet transform identifier: 0 = 9-7 irreversible, 1 = 5-3 reversible"]
    pub qmfbid: OPJ_UINT32,
    #[doc = " quantisation style"]
    pub qntsty: OPJ_UINT32,
    #[doc = " stepsizes used for quantization"]
    pub stepsizes_mant: [OPJ_UINT32; 97usize],
    #[doc = " stepsizes used for quantization"]
    pub stepsizes_expn: [OPJ_UINT32; 97usize],
    #[doc = " number of guard bits"]
    pub numgbits: OPJ_UINT32,
    #[doc = " Region Of Interest shift"]
    pub roishift: OPJ_INT32,
    #[doc = " precinct width"]
    pub prcw: [OPJ_UINT32; 33usize],
    #[doc = " precinct height"]
    pub prch: [OPJ_UINT32; 33usize],
}
#[doc = " Tile-component coding parameters information"]
pub type opj_tccp_info_t = opj_tccp_info;
#[doc = " Tile coding parameters information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_v2_info {
    #[doc = " number (index) of tile"]
    pub tileno: c_int,
    #[doc = " coding style"]
    pub csty: OPJ_UINT32,
    #[doc = " progression order"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = " number of layers"]
    pub numlayers: OPJ_UINT32,
    #[doc = " multi-component transform identifier"]
    pub mct: OPJ_UINT32,
    #[doc = " information concerning tile component parameters"]
    pub tccp_info: *mut opj_tccp_info_t,
}
#[doc = " Tile coding parameters information"]
pub type opj_tile_info_v2_t = opj_tile_v2_info;
#[doc = " Information structure about the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info_v2 {
    #[doc = " tile origin in x = XTOsiz"]
    pub tx0: OPJ_UINT32,
    #[doc = " tile origin in y = YTOsiz"]
    pub ty0: OPJ_UINT32,
    #[doc = " tile size in x = XTsiz"]
    pub tdx: OPJ_UINT32,
    #[doc = " tile size in y = YTsiz"]
    pub tdy: OPJ_UINT32,
    #[doc = " number of tiles in X"]
    pub tw: OPJ_UINT32,
    #[doc = " number of tiles in Y"]
    pub th: OPJ_UINT32,
    #[doc = " number of components"]
    pub nbcomps: OPJ_UINT32,
    #[doc = " Default information regarding tiles inside image"]
    pub m_default_tile_info: opj_tile_info_v2_t,
    #[doc = " information regarding tiles inside image"]
    pub tile_info: *mut opj_tile_info_v2_t,
}
#[doc = " Information structure about the codestream (FIXME should be expand and enhance)"]
pub type opj_codestream_info_v2_t = opj_codestream_info_v2;
#[doc = " Index structure about a tile part"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_index {
    #[doc = " start position"]
    pub start_pos: OPJ_OFF_T,
    #[doc = " end position of the header"]
    pub end_header: OPJ_OFF_T,
    #[doc = " end position"]
    pub end_pos: OPJ_OFF_T,
}
#[doc = " Index structure about a tile part"]
pub type opj_tp_index_t = opj_tp_index;
#[doc = " Index structure about a tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_index {
    #[doc = " tile index"]
    pub tileno: OPJ_UINT32,
    #[doc = " number of tile parts"]
    pub nb_tps: OPJ_UINT32,
    #[doc = " current nb of tile part (allocated)"]
    pub current_nb_tps: OPJ_UINT32,
    #[doc = " current tile-part index"]
    pub current_tpsno: OPJ_UINT32,
    #[doc = " information concerning tile parts"]
    pub tp_index: *mut opj_tp_index_t,
    #[doc = " number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    #[doc = " packet number"]
    pub nb_packet: OPJ_UINT32,
    #[doc = " information concerning packets inside tile"]
    pub packet_index: *mut opj_packet_info_t,
}
#[doc = " Index structure about a tile"]
pub type opj_tile_index_t = opj_tile_index;
#[doc = " Index structure of the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_index {
    #[doc = " main header start position (SOC position)"]
    pub main_head_start: OPJ_OFF_T,
    #[doc = " main header end position (first SOT position)"]
    pub main_head_end: OPJ_OFF_T,
    #[doc = " codestream's size"]
    pub codestream_size: OPJ_UINT64,
    #[doc = " number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    pub nb_of_tiles: OPJ_UINT32,
    pub tile_index: *mut opj_tile_index_t,
}
#[doc = " Index structure of the codestream (FIXME should be expand and enhance)"]
pub type opj_codestream_index_t = opj_codestream_index;
#[doc = " Info structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_metadata {
    pub not_used: OPJ_INT32,
}
#[doc = " Info structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
pub type opj_jp2_metadata_t = opj_jp2_metadata;
#[doc = " Index structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_index {
    pub not_used: OPJ_INT32,
}
#[doc = " Index structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
pub type opj_jp2_index_t = opj_jp2_index;
extern "C" {
    pub fn opj_version() -> *const c_char;
}
extern "C" {
    #[doc = " Create an image"]
    #[doc = ""]
    #[doc = "* `numcmpts` —       number of components"]
    #[doc = "* `cmptparms` —      components parameters"]
    #[doc = "* `clrspc` —         image color space"]
    #[doc = "\n`returns` —       a new image structure if successful, returns NULL otherwise"]
    pub fn opj_image_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = " Deallocate any resources associated with an image"]
    #[doc = ""]
    #[doc = "* `image` —          image to be destroyed"]
    pub fn opj_image_destroy(image: *mut opj_image_t);
}
extern "C" {
    #[doc = " Creates an image without allocating memory for the image (used in the new version of the library)."]
    #[doc = ""]
    #[doc = "* `numcmpts` —     the number of components"]
    #[doc = "* `cmptparms` —    the components parameters"]
    #[doc = "* `clrspc` —       the image color space"]
    #[doc = ""]
    #[doc = "\n`a` —  new image structure if successful, NULL otherwise."]
    pub fn opj_image_tile_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = " Allocator for opj_image_t->comps[].data"]
    #[doc = " To be paired with opj_image_data_free."]
    #[doc = ""]
    #[doc = "* `size` —     number of bytes to allocate"]
    #[doc = ""]
    #[doc = "\n`a` —  new pointer if successful, NULL otherwise."]
    #[doc = " @since 2.2.0"]
    pub fn opj_image_data_alloc(size: OPJ_SIZE_T) -> *mut c_void;
}
extern "C" {
    #[doc = " Destructor for opj_image_t->comps[].data"]
    #[doc = " To be paired with opj_image_data_alloc."]
    #[doc = ""]
    #[doc = "* `ptr` —     Pointer to free"]
    #[doc = ""]
    #[doc = " @since 2.2.0"]
    pub fn opj_image_data_free(ptr: *mut c_void);
}
extern "C" {
    #[doc = " Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream."]
    #[doc = ""]
    #[doc = "* `p_is_input` —       if set to true then the stream will be an input stream, an output stream else."]
    #[doc = ""]
    #[doc = "\n`a` —  stream object."]
    pub fn opj_stream_default_create(p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream."]
    #[doc = ""]
    #[doc = "* `p_buffer_size` —   FIXME DOC"]
    #[doc = "* `p_is_input` —       if set to true then the stream will be an input stream, an output stream else."]
    #[doc = ""]
    #[doc = "\n`a` —  stream object."]
    pub fn opj_stream_create(p_buffer_size: OPJ_SIZE_T, p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Destroys a stream created by opj_create_stream. This function does NOT close the abstract stream. If needed the user must"]
    #[doc = " close its own implementation of the stream."]
    #[doc = ""]
    #[doc = "* `p_stream` —     the stream to destroy."]
    pub fn opj_stream_destroy(p_stream: *mut opj_stream_t);
}
extern "C" {
    #[doc = " Sets the given function to be used as a read function."]
    #[doc = "* `p_stream` —     the stream to modify"]
    #[doc = "* `p_function` —   the function to use a read function."]
    pub fn opj_stream_set_read_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_read_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a write function."]
    #[doc = "* `p_stream` —     the stream to modify"]
    #[doc = "* `p_function` —   the function to use a write function."]
    pub fn opj_stream_set_write_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_write_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a skip function."]
    #[doc = "* `p_stream` —     the stream to modify"]
    #[doc = "* `p_function` —   the function to use a skip function."]
    pub fn opj_stream_set_skip_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_skip_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a seek function, the stream is then seekable,"]
    #[doc = " using SEEK_SET behavior."]
    #[doc = "* `p_stream` —     the stream to modify"]
    #[doc = "* `p_function` —   the function to use a skip function."]
    pub fn opj_stream_set_seek_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_seek_fn,
    );
}
extern "C" {
    #[doc = " Sets the given data to be used as a user data for the stream."]
    #[doc = "* `p_stream` —     the stream to modify"]
    #[doc = "* `p_data` —       the data to set."]
    #[doc = "* `p_function` —   the function to free p_data when opj_stream_destroy() is called."]
    pub fn opj_stream_set_user_data(
        p_stream: *mut opj_stream_t,
        p_data: *mut c_void,
        p_function: opj_stream_free_user_data_fn,
    );
}
extern "C" {
    #[doc = " Sets the length of the user data for the stream."]
    #[doc = ""]
    #[doc = "* `p_stream` —     the stream to modify"]
    #[doc = "* `data_length` —  length of the user_data."]
    pub fn opj_stream_set_user_data_length(p_stream: *mut opj_stream_t, data_length: OPJ_UINT64);
}
extern "C" {
    #[doc = " Create a stream from a file identified with its filename with default parameters (helper function)"]
    #[doc = "* `fname` —              the filename of the file to stream"]
    #[doc = "* `p_is_read_stream` —   whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_default_file_stream(
        fname: *const c_char,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Create a stream from a file identified with its filename with a specific buffer size"]
    #[doc = "* `fname` —              the filename of the file to stream"]
    #[doc = "* `p_buffer_size` —      size of the chunk used to stream"]
    #[doc = "* `p_is_read_stream` —   whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_file_stream(
        fname: *const c_char,
        p_buffer_size: OPJ_SIZE_T,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Set the info handler use by openjpeg."]
    #[doc = "* `p_codec` —        the codec previously initialise"]
    #[doc = "* `p_callback` —     the callback function which will be used"]
    #[doc = "* `p_user_data` —    client object where will be returned the message"]
    pub fn opj_set_info_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the warning handler use by openjpeg."]
    #[doc = "* `p_codec` —        the codec previously initialise"]
    #[doc = "* `p_callback` —     the callback function which will be used"]
    #[doc = "* `p_user_data` —    client object where will be returned the message"]
    pub fn opj_set_warning_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the error handler use by openjpeg."]
    #[doc = "* `p_codec` —        the codec previously initialise"]
    #[doc = "* `p_callback` —     the callback function which will be used"]
    #[doc = "* `p_user_data` —    client object where will be returned the message"]
    pub fn opj_set_error_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Creates a J2K/JP2 decompression structure"]
    #[doc = "* `format` —         Decoder to select"]
    #[doc = ""]
    #[doc = "\n`Returns` —  a handle to a decompressor if successful, returns NULL otherwise"]
    pub fn opj_create_decompress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = " Destroy a decompressor handle"]
    #[doc = ""]
    #[doc = "* `p_codec` —          decompressor handle to destroy"]
    pub fn opj_destroy_codec(p_codec: *mut opj_codec_t);
}
extern "C" {
    #[doc = " Read after the codestream if necessary"]
    #[doc = "* `p_codec` —          the JPEG2000 codec to read."]
    #[doc = "* `p_stream` —         the JPEG2000 stream."]
    pub fn opj_end_decompress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set decoding parameters to default values"]
    #[doc = "* `parameters` —  Decompression parameters"]
    pub fn opj_set_default_decoder_parameters(parameters: *mut opj_dparameters_t);
}
extern "C" {
    #[doc = " Setup the decoder with decompression parameters provided by the user and with the message handler"]
    #[doc = " provided by the user."]
    #[doc = ""]
    #[doc = "* `p_codec` —        decompressor handler"]
    #[doc = "* `parameters` —     decompression parameters"]
    #[doc = ""]
    #[doc = "\n`true` —          if the decoder is correctly set"]
    pub fn opj_setup_decoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_dparameters_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Allocates worker threads for the compressor/decompressor."]
    #[doc = ""]
    #[doc = " By default, only the main thread is used. If this function is not used,"]
    #[doc = " but the OPJ_NUM_THREADS environment variable is set, its value will be"]
    #[doc = " used to initialize the number of threads. The value can be either an integer"]
    #[doc = " number, or \"ALL_CPUS\". If OPJ_NUM_THREADS is set and this function is called,"]
    #[doc = " this function will override the behaviour of the environment variable."]
    #[doc = ""]
    #[doc = " Currently this function must be called after opj_setup_decoder() and"]
    #[doc = " before opj_read_header()."]
    #[doc = ""]
    #[doc = " Note: currently only has effect on the decompressor."]
    #[doc = ""]
    #[doc = "* `p_codec` —        decompressor handler"]
    #[doc = "* `num_threads` —    number of threads."]
    #[doc = ""]
    #[doc = "\n`OPJ_TRUE` —      if the decoder is correctly set"]
    pub fn opj_codec_set_threads(p_codec: *mut opj_codec_t, num_threads: c_int) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Decodes an image header."]
    #[doc = ""]
    #[doc = "* `p_stream` —         the jpeg2000 stream."]
    #[doc = "* `p_codec` —          the jpeg2000 codec to read."]
    #[doc = "* `p_image` —          the image structure initialized with the characteristics of encoded image."]
    #[doc = ""]
    #[doc = "\n`true` —              if the main header of the codestream and the JP2 header is correctly read."]
    pub fn opj_read_header(
        p_stream: *mut opj_stream_t,
        p_codec: *mut opj_codec_t,
        p_image: *mut *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Restrict the number of components to decode."]
    #[doc = ""]
    #[doc = " This function should be called after opj_read_header()."]
    #[doc = ""]
    #[doc = " This function enables to restrict the set of decoded components to the"]
    #[doc = " specified indices."]
    #[doc = " Note that the current implementation (apply_color_transforms == OPJ_FALSE)"]
    #[doc = " is such that neither the multi-component transform at codestream level,"]
    #[doc = " nor JP2 channel transformations will be applied."]
    #[doc = " Consequently the indices are relative to the codestream."]
    #[doc = ""]
    #[doc = " Note: opj_decode_tile_data() should not be used together with opj_set_decoded_components()."]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec to read."]
    #[doc = "* `numcomps` —         Size of the comps_indices array."]
    #[doc = "* `comps_indices` —    Array of numcomps values representing the indices"]
    #[doc = "                          of the components to decode (relative to the"]
    #[doc = "                          codestream, starting at 0)"]
    #[doc = "* `apply_color_transforms` —  Whether multi-component transform at codestream level"]
    #[doc = "                                 or JP2 channel transformations should be applied."]
    #[doc = "                                 Currently this parameter should be set to OPJ_FALSE."]
    #[doc = "                                 Setting it to OPJ_TRUE will result in an error."]
    #[doc = ""]
    #[doc = "\n`OPJ_TRUE` —          in case of success."]
    pub fn opj_set_decoded_components(
        p_codec: *mut opj_codec_t,
        numcomps: OPJ_UINT32,
        comps_indices: *const OPJ_UINT32,
        apply_color_transforms: OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Sets the given area to be decoded. This function should be called right after opj_read_header and before any tile header reading."]
    #[doc = ""]
    #[doc = " The coordinates passed to this function should be expressed in the reference grid,"]
    #[doc = " that is to say at the highest resolution level, even if requesting the image at lower"]
    #[doc = " resolution levels."]
    #[doc = ""]
    #[doc = " Generally opj_set_decode_area() should be followed by opj_decode(), and the"]
    #[doc = " codec cannot be re-used."]
    #[doc = " In the particular case of an image made of a single tile, several sequences of"]
    #[doc = " calls to opoj_set_decode_area() and opj_decode() are allowed, and will bring"]
    #[doc = " performance improvements when reading an image by chunks."]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = "* `p_image` —          the decoded image previously set by opj_read_header"]
    #[doc = "* `p_start_x` —        the left position of the rectangle to decode (in image coordinates)."]
    #[doc = "* `p_end_x` —          the right position of the rectangle to decode (in image coordinates)."]
    #[doc = "* `p_start_y` —        the up position of the rectangle to decode (in image coordinates)."]
    #[doc = "* `p_end_y` —          the bottom position of the rectangle to decode (in image coordinates)."]
    #[doc = ""]
    #[doc = "\n`true` —             if the area could be set."]
    pub fn opj_set_decode_area(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_start_x: OPJ_INT32,
        p_start_y: OPJ_INT32,
        p_end_x: OPJ_INT32,
        p_end_y: OPJ_INT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Decode an image from a JPEG-2000 codestream"]
    #[doc = ""]
    #[doc = "* `p_decompressor` —     decompressor handle"]
    #[doc = "* `p_stream` —           Input buffer stream"]
    #[doc = "* `p_image` —            the decoded image"]
    #[doc = "\n`true` —  if success, otherwise false"]
    pub fn opj_decode(
        p_decompressor: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Get the decoded tile from the codec"]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = "* `p_stream` —         input streamm"]
    #[doc = "* `p_image` —          output image"]
    #[doc = "* `tile_index` —       index of the tile which will be decode"]
    #[doc = ""]
    #[doc = "\n`true` —  if success, otherwise false"]
    pub fn opj_get_decoded_tile(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
        tile_index: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the resolution factor of the decoded image"]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = "* `res_factor` —       resolution factor to set"]
    #[doc = ""]
    #[doc = "\n`true` —  if success, otherwise false"]
    pub fn opj_set_decoded_resolution_factor(
        p_codec: *mut opj_codec_t,
        res_factor: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Writes a tile with the given data."]
    #[doc = ""]
    #[doc = "* `p_codec` —              the jpeg2000 codec."]
    #[doc = "* `p_tile_index` —         the index of the tile to write. At the moment, the tiles must be written from 0 to n-1 in sequence."]
    #[doc = "* `p_data` —               pointer to the data to write. Data is arranged in sequence, data_comp0, then data_comp1, then ... NO INTERLEAVING should be set."]
    #[doc = "* `p_data_size` —          this value os used to make sure the data being written is correct. The size must be equal to the sum for each component of"]
    #[doc = "                              tile_width * tile_height * component_size. component_size can be 1,2 or 4 bytes, depending on the precision of the given component."]
    #[doc = "* `p_stream` —             the stream to write data to."]
    #[doc = ""]
    #[doc = "\n`true` —  if the data could be written."]
    pub fn opj_write_tile(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Reads a tile header. This function is compulsory and allows one to know the size of the tile that will be decoded."]
    #[doc = " The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile."]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = "* `p_tile_index` —     pointer to a value that will hold the index of the tile being decoded, in case of success."]
    #[doc = "* `p_data_size` —      pointer to a value that will hold the maximum size of the decoded data, in case of success. In case"]
    #[doc = "                          of truncated codestreams, the actual number of bytes decoded may be lower. The computation of the size is the same"]
    #[doc = "                          as depicted in opj_write_tile."]
    #[doc = "* `p_tile_x0` —        pointer to a value that will hold the x0 pos of the tile (in the image)."]
    #[doc = "* `p_tile_y0` —        pointer to a value that will hold the y0 pos of the tile (in the image)."]
    #[doc = "* `p_tile_x1` —        pointer to a value that will hold the x1 pos of the tile (in the image)."]
    #[doc = "* `p_tile_y1` —        pointer to a value that will hold the y1 pos of the tile (in the image)."]
    #[doc = "* `p_nb_comps` —       pointer to a value that will hold the number of components in the tile."]
    #[doc = "* `p_should_go_on` —   pointer to a boolean that will hold the fact that the decoding should go on. In case the"]
    #[doc = "                          codestream is over at the time of the call, the value will be set to false. The user should then stop"]
    #[doc = "                          the decoding."]
    #[doc = "* `p_stream` —         the stream to decode."]
    #[doc = "\n`true` —             if the tile header could be decoded. In case the decoding should end, the returned value is still true."]
    #[doc = "                          returning false may be the result of a shortage of memory or an internal error."]
    pub fn opj_read_tile_header(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_tile_index: *mut OPJ_UINT32,
        p_data_size: *mut OPJ_UINT32,
        p_tile_x0: *mut OPJ_INT32,
        p_tile_y0: *mut OPJ_INT32,
        p_tile_x1: *mut OPJ_INT32,
        p_tile_y1: *mut OPJ_INT32,
        p_nb_comps: *mut OPJ_UINT32,
        p_should_go_on: *mut OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Reads a tile data. This function is compulsory and allows one to decode tile data. opj_read_tile_header should be called before."]
    #[doc = " The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile."]
    #[doc = ""]
    #[doc = " Note: opj_decode_tile_data() should not be used together with opj_set_decoded_components()."]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = "* `p_tile_index` —     the index of the tile being decoded, this should be the value set by opj_read_tile_header."]
    #[doc = "* `p_data` —           pointer to a memory block that will hold the decoded data."]
    #[doc = "* `p_data_size` —      size of p_data. p_data_size should be bigger or equal to the value set by opj_read_tile_header."]
    #[doc = "* `p_stream` —         the stream to decode."]
    #[doc = ""]
    #[doc = "\n`true` —             if the data could be decoded."]
    pub fn opj_decode_tile_data(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Creates a J2K/JP2 compression structure"]
    #[doc = "* `format` —       Coder to select"]
    #[doc = "\n`Returns` —  a handle to a compressor if successful, returns NULL otherwise"]
    pub fn opj_create_compress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = "Set encoding parameters to default values, that means :"]
    #[doc = "<ul>"]
    #[doc = "<li>Lossless"]
    #[doc = "<li>1 tile"]
    #[doc = "<li>Size of precinct : 2^15 x 2^15 (means 1 precinct)"]
    #[doc = "<li>Size of code-block : 64 x 64"]
    #[doc = "<li>Number of resolutions: 6"]
    #[doc = "<li>No SOP marker in the codestream"]
    #[doc = "<li>No EPH marker in the codestream"]
    #[doc = "<li>No sub-sampling in x or y direction"]
    #[doc = "<li>No mode switch activated"]
    #[doc = "<li>Progression order: LRCP"]
    #[doc = "<li>No index file"]
    #[doc = "<li>No ROI upshifted"]
    #[doc = "<li>No offset of the origin of the image"]
    #[doc = "<li>No offset of the origin of the tiles"]
    #[doc = "<li>Reversible DWT 5-3"]
    #[doc = "</ul>"]
    #[doc = "* `parameters` —  Compression parameters"]
    pub fn opj_set_default_encoder_parameters(parameters: *mut opj_cparameters_t);
}
extern "C" {
    #[doc = " Setup the encoder parameters using the current image and using user parameters."]
    #[doc = "* `p_codec` —        Compressor handle"]
    #[doc = "* `parameters` —     Compression parameters"]
    #[doc = "* `image` —          Input filled image"]
    pub fn opj_setup_encoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_cparameters_t,
        image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Start to compress the current image."]
    #[doc = "* `p_codec` —        Compressor handle"]
    #[doc = "* `p_image` —        Input filled image"]
    #[doc = "* `p_stream` —       Input stgream"]
    pub fn opj_start_compress(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " End to compress the current image."]
    #[doc = "* `p_codec` —        Compressor handle"]
    #[doc = "* `p_stream` —       Input stgream"]
    pub fn opj_end_compress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Encode an image into a JPEG-2000 codestream"]
    #[doc = "* `p_codec` —        compressor handle"]
    #[doc = "* `p_stream` —       Output buffer stream"]
    #[doc = ""]
    #[doc = "\n`Returns` —  true if successful, returns false otherwise"]
    pub fn opj_encode(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Destroy Codestream information after compression or decompression"]
    #[doc = "* `cstr_info` —  Codestream information structure"]
    pub fn opj_destroy_cstr_info(cstr_info: *mut *mut opj_codestream_info_v2_t);
}
extern "C" {
    #[doc = " Dump the codec information into the output stream"]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = "* `info_flag` —        type of information dump."]
    #[doc = "* `output_stream` —    output stream where dump the information gotten from the codec."]
    #[doc = ""]
    pub fn opj_dump_codec(
        p_codec: *mut opj_codec_t,
        info_flag: OPJ_INT32,
        output_stream: *mut FILE,
    );
}
extern "C" {
    #[doc = " Get the codestream information from the codec"]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = ""]
    #[doc = "\n`a` —  pointer to a codestream information structure."]
    #[doc = ""]
    pub fn opj_get_cstr_info(p_codec: *mut opj_codec_t) -> *mut opj_codestream_info_v2_t;
}
extern "C" {
    #[doc = " Get the codestream index from the codec"]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = ""]
    #[doc = "\n`a` —  pointer to a codestream index structure."]
    #[doc = ""]
    pub fn opj_get_cstr_index(p_codec: *mut opj_codec_t) -> *mut opj_codestream_index_t;
}
extern "C" {
    pub fn opj_destroy_cstr_index(p_cstr_index: *mut *mut opj_codestream_index_t);
}
extern "C" {
    #[doc = " Get the JP2 file information from the codec FIXME"]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = ""]
    #[doc = "\n`a` —  pointer to a JP2 metadata structure."]
    #[doc = ""]
    pub fn opj_get_jp2_metadata(p_codec: *mut opj_codec_t) -> *mut opj_jp2_metadata_t;
}
extern "C" {
    #[doc = " Get the JP2 file index from the codec FIXME"]
    #[doc = ""]
    #[doc = "* `p_codec` —          the jpeg2000 codec."]
    #[doc = ""]
    #[doc = "\n`a` —  pointer to a JP2 index structure."]
    #[doc = ""]
    pub fn opj_get_jp2_index(p_codec: *mut opj_codec_t) -> *mut opj_jp2_index_t;
}
extern "C" {
    #[doc = " Sets the MCT matrix to use."]
    #[doc = ""]
    #[doc = "* `parameters` —       the parameters to change."]
    #[doc = "* `pEncodingMatrix` —  the encoding matrix."]
    #[doc = "* `p_dc_shift` —       the dc shift coefficients to use."]
    #[doc = "* `pNbComp` —          the number of components of the image."]
    #[doc = ""]
    #[doc = "\n`true` —  if the parameters could be set."]
    pub fn opj_set_MCT(
        parameters: *mut opj_cparameters_t,
        pEncodingMatrix: *mut OPJ_FLOAT32,
        p_dc_shift: *mut OPJ_INT32,
        pNbComp: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Returns if the library is built with thread support."]
    #[doc = " OPJ_TRUE if mutex, condition, thread, thread pool are available."]
    pub fn opj_has_thread_support() -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Return the number of virtual CPUs"]
    pub fn opj_get_num_cpus() -> c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut c_char;
